// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

/**
    * @title Auditor
    * @notice Allows the submission of smart contracts for security reviews.
    * @dev A contract that receives the source code of smart contracts for audits

    * @author @keyrxng
 */


contract Auditor {

    address public Manager;

    uint public auditID; // auto incremented ID for newly submitted audit (for review by auditors) to keep track of the list - will be used as indexes to the mappings
    uint public auditFee; // to be set by the audit team, this is the fee each contract submission will cost

    mapping(uint=>bytes) public sourceCodes; // a mapping to store the full source code for a submitted contract (Repo URL or similar) (includes main and all associated contract files)
    mapping(uint=>mapping(uint=>bytes)) public lows; // mapping to store the list of all submitted low severity contract audit issues
    mapping(uint=>mapping(uint=>bytes)) public med; // mapping to store the list of all submitted medium severity contract audit issues
    mapping(uint=>mapping(uint=>bytes)) public high; // mapping to store the list of all submitted high severity contract audit issues

    mapping(uint=>audit) public audits; // mapping to store the list of submitted audit for review details
    mapping(uint=>address) public auditor; // mapping to store the Ethereum address of the auditor who reviewed the code for a contract

    audit[] public auditQueue; // a queue to keep a list of submitted audits for auditors to pick and review next
    mapping(address=>uint) public auditorQueue; // a queue that stores the number of code reviews an auditor has currently, allowing audits to be assigned to auditors

    event SourceCodeSubmitted (uint indexed auditId, address submitter, string indexed protocolName); // emitted when a contract source code is submitted for review
    event AuditCompleted (address indexed auditor, uint lowSeverityIssues, uint medSeverityIssues, uint highSeverityIssues); // emitted when an audit is complete and has no more open issues

    error InsufficientValue(uint256 required, uint256 got); 

    constructor () {
        Manager = msg.sender;
    }

    modifier onlyManager {
        require(msg.sender == Manager, "not Manager");
        _;
    }

    struct audit {
        address submitter; // this is the address of the person who submitted the code for review
        bool isReviewed; // this will determine if the audit is complete or not
        uint256 dateSubmitted; // timestamp of the date the contract source code was submitted for review
        bytes comments; // comments from the review team
        bytes protocolName; // // protocol name from the submission form
        uint low; // number of low severity issues raised during audit
        uint med; // number of medium severity issues raised during audit
        uint high; // number of high severity issues raised during audit
        uint auditId; // auditID generated by the contract
    }

    /**
        * @notice submit contract source code for review
        * @param protocolName name of the protocol (provided by the submitter)
        * @param comments comments from the protocol
    */

    function requestAudit(bytes memory protocolName, bytes memory comments, bytes memory _repo) public payable {
        if(msg.value < getAuditSubmissionCost()){
            revert  InsufficientValue({ required: getAuditSubmissionCost(), got:msg.value });
        }

        audit memory newAudit = audit({submitter: msg.sender, isReviewed: false, dateSubmitted: block.timestamp, comments: comments, protocolName: protocolName, low: 0, med: 0, high: 0, auditId: auditID});

        audits[auditID] = newAudit;

        auditQueue.push(newAudit); 

        sourceCodes[auditID] = _repo;
        auditID++;

        emit SourceCodeSubmitted(auditID, msg.sender, "");
    }

    /**
        * @notice defines the audit fee
        * @param _amount the amount of the chosen cryptocurrency to be payed
        * @dev can only be set by Manager
    */

    function setAuditFee(uint _amount) public onlyManager {
        auditFee = _amount;

    }

    /**
        * @notice given the amount of audits in the queue determines the audit fee, increasing expoentially with more audits in the queue
        * @return the audit fee based on the amount of audits in the queue
        * Example: auditFee == 3, queueLength = 4, cost = 3 * 4 / 5 = 2.4 ETH
        * Example: auditFee == 3, queueLength = 9, cost = 3 * 9 / 5 = 5.4 ETH
        * Example: auditFee == 3, queueLength = 1, cost = 3 * 1 / 5 = 0.6 ETH
        * Example: auditFee == 5, queueLength = 0, cost = 5 * 0 / 5 = 0 ETH
        * @dev could be extended to take multiple cryptocurrencies, right now is only set for ETH
    */
    
    function getAuditSubmissionCost() public view returns (uint) {
        uint cost = auditFee * auditQueue.length / 5; // audit fee * number of audits in the auditQueue / factor by which fee will increase
        if(cost == 0) {
            return (1 ether / 2);
        }
        return cost;
    }

    /**
        * @notice allows externally contracts and wallets to send funds to the this address
    */

    receive() external payable { 
        require(msg.value > 0); 
    }

    
    fallback() external payable {
    }




}
