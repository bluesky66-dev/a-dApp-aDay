// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

/**
    * @title Auditor
    * @notice Allows the submission of smart contracts for security reviews.
    * @dev A contract that receives the source code of smart contracts for audits

    * @author @keyrxng
 */


contract Auditor {

    address public Manager;

    uint public auditID; // auto incremented ID for newly submitted audit (for review by auditors) to keep track of the list - will be used as indexes to the mappings
    uint public auditFee; // to be set by the audit team, this is the fee each contract submission will cost
    uint public auditorID; // auto incremented ID for newly added auditor
    uint public auditorRegFee; // set by the audit team, this is the fee for auditors to register with the system as a valid member of team

    mapping(uint=>bytes) public sourceCodes; // a mapping to store the full source code for a submitted contract (Repo URL or similar) (includes main and all associated contract files)
    mapping(uint=>mapping(uint=>bytes)) public lows; // mapping to store the list of all submitted low severity contract audit issues
    mapping(uint=>mapping(uint=>bytes)) public meds; // mapping to store the list of all submitted medium severity contract audit issues
    mapping(uint=>mapping(uint=>bytes)) public highs; // mapping to store the list of all submitted high severity contract audit issues

    mapping(uint=>audit) public audits; // mapping to store the list of submitted audit for review details
    mapping(uint=>address) public auditorIDToAddr; // mapping to store the Ethereum address of the auditor who reviewed the code for a contract
    mapping(address=>uint) public auditorAddrToID; // a list of all auditors and their audit IDs - will be used as indexes to the mappings
    mapping(address=>uint) public auditorQueue; // a queue that stores the number of code reviews an auditor has currently, allowing audits to be assigned to auditors

    audit[] public auditQueue; // a queue to keep a list of submitted audits for auditors to pick and review next
    accAuditor[] public auditorDetails; // details of each auditor

    event SourceCodeSubmitted (uint indexed auditId, address submitter, string indexed protocolName); // emitted when a contract source code is submitted for review
    event AuditCompleted (uint lowSeverityIssues, uint medSeverityIssues, uint highSeverityIssues); // emitted when an audit is complete and has no more open issues
    event NewAuditorAdded (address indexed newAuditor, bytes indexed protocolName); // emitted when a new auditor has registered with the system
    event AuditAssigned(address indexed auditor, uint indexed auditId); // emitted when an audit is assigned to an auditor

    error InsufficientValue(uint256 required, uint256 got); // emitted when submitted value is not enough to submit audit request

    constructor () {
        Manager = msg.sender;
        auditID = 1; // set the initial ID that will be used for a new audit to be submitted for review
        auditorID = 1; // set the initial ID that will be used for a new auditor to be added to the system by the audit team
        auditorIDToAddr[0] = address(0);
        auditorAddrToID[address(0)] = 0;
    }

    modifier onlyManager {
        require(msg.sender == Manager, "not Manager");
        _;
    }

    struct accAuditor {
        address auditor; // Address of the auditor
        uint numberOfSubmits; // Number of audits a user has submitted (useful if one auditor submits several audits in one go)
        uint highs; // The total number of high severity issues raised by an auditor across all audits
        uint meds; // The total number of medium severity issues raised by an auditor across all audits
        uint lows; // The total number of low severity issues raised by an auditor across all audits
        uint total; // The total number of issues raised by an auditor across all audits
        bool isActive; // Whether an auditor is still an active member of the team or not
    }

    struct audit {
        address submitter; // this is the address of the person who submitted the code for review
        bool isReviewed; // this will determine if the audit is complete or not
        uint256 dateSubmitted; // timestamp of the date the contract source code was submitted for review
        bytes comments; // comments from the review team
        bytes protocolName; // // protocol name from the submission form
        uint low; // number of low severity issues raised during audit
        uint med; // number of medium severity issues raised during audit
        uint high; // number of high severity issues raised during audit
        uint auditId; // auditID generated by the contract
        address[] assigned; // a mapping of auditors who reviewed the audit code
    }

    /**
        * @notice submit contract source code for review
        * @param protocolName name of the protocol (provided by the submitter)
        * @param comments comments from the protocol
    */

    function requestAudit(bytes memory protocolName, bytes memory comments, bytes memory _repo) public payable {
        if(msg.value < getAuditSubmissionCost()){
            revert  InsufficientValue({ required: getAuditSubmissionCost(), got:msg.value });
        }

        uint subID = auditID;

        audit memory newAudit = audit({submitter: msg.sender, isReviewed: false, dateSubmitted: block.timestamp, comments: comments, protocolName: protocolName, low: 0, med: 0, high: 0, auditId: subID, assigned: new address[](0)});

        audits[subID] = newAudit;

        auditQueue.push(newAudit); 

        sourceCodes[subID] = _repo;
        
        auditID++;

        emit SourceCodeSubmitted(subID, msg.sender, "");
    }

    /**
        * @notice defines the audit fee
        * @param _amount the amount of the chosen cryptocurrency to be payed
        * @dev can only be set by Manager
    */

    function setAuditFee(uint _amount) public onlyManager {
        auditFee = _amount;
    }

    /**
        * @notice given the amount of audits in the queue determines the audit fee, increasing expoentially with more audits in the queue
        * @return the audit fee based on the amount of audits in the queue
        * Example: auditFee == 3, queueLength = 4, cost = 3 * 4 / 5 = 2.4 ETH
        * Example: auditFee == 3, queueLength = 9, cost = 3 * 9 / 5 = 5.4 ETH
        * Example: auditFee == 3, queueLength = 1, cost = 3 * 1 / 5 = 0.6 ETH
        * Example: auditFee == 5, queueLength = 0, cost = 5 * 0 / 5 = 0 ETH
        * @dev could be extended to take multiple cryptocurrencies, right now is only set for ETH
    */
    
    function getAuditSubmissionCost() public view returns (uint) {
        uint cost = auditFee * auditQueue.length / 5; // audit fee * number of audits in the auditQueue / factor by which fee will increase
        if(cost == 0) {
            return (1 ether / 2);
        }
        return cost;
    }


    /**
        * @notice registers a new auditor
        * @param newAuditor address of the new auditor
        * @dev can only be set by Manager
    */

    function registerAuditor(address newAuditor) public payable {
        if(msg.value < getAuditorCost()){
            revert  InsufficientValue({ required: getAuditorCost(), got:msg.value });
        }

        auditorDetails.push(accAuditor({auditor: newAuditor, numberOfSubmits: 0, highs: 0, meds: 0, lows: 0, total: 0, isActive: true}));
        auditorID++;
        auditorAddrToID[newAuditor] = auditorID;
        auditorIDToAddr[auditorID] = newAuditor;

    }

    /**
        * @notice sets the price for auditors to register in the system
        * @param _amount the amount of the chosen cryptocurrency to be payed
        * @dev can only be set by Manager
    */

    function setAuditorFee(uint _amount) public onlyManager {
        auditorRegFee = _amount;
    }

    /**
        * @notice given the amount of auditors in the registry determines the fee for registering, increasing expoentially with more auditors
        * @return the fee for registering an auditor based on the amount of auditors in the system
        * Example: auditorRegFee == 0.1, auditorID = 250, cost = 0.1 * 250 / 5 = 5 ETH
        * Example: auditorRegFee == 0.1, auditorID = 99, cost = 0.1 * 99 / 5 = 1.8 ETH
        * Example: auditorRegFee == 0.1, auditorID = 10, cost = 0.1 * 10 / 5 = 0.2 ETH
        * Example: auditorRegFee == 0.1, auditorID = 1, cost = 0.1 * 1 / 5 = 0.02 ETH
        * Example: auditorRegFee == 0.1, auditorID = 0, cost = 0.1 * 0 / 5 = 0 ETH        
    */

    function getAuditorCost() public view returns (uint) {
        uint cost = auditorRegFee * auditorDetails.length / 5; // auditor registration fee * number of accounts registered / factor by which fee will increase
        return cost;
    }

    /**
        * @notice removes an auditor based on the provided account id by removing from mappings and setting isActive to false
        * @param id id of the auditor account
        * @dev can only be set by Manager
    */

    function removeAuditor(uint id) public onlyManager returns(bool) {
        address who = auditorIDToAddr[id];
        delete auditorAddrToID[who];
        delete auditorIDToAddr[id];
        auditorDetails[id].isActive = false;
        return true;
    }

    /**
        * @notice assigns an audit to an auditor called by the auditor themselves
        * @param id id of the audit
    */

    function assignAudit(uint id) public returns(bool) {
        require(audits[id].isReviewed == false);
        // require(auditorDetails[auditorAddrToID[msg.sender]].isActive == true); // add way to ensure only active auditors can assign an audit

        auditorQueue[msg.sender] = id;
        audits[id].assigned.push(msg.sender);

        emit AuditAssigned(msg.sender, id);
    }

    /**
        * @notice allows an auditor to submit findings for a given audit
        * @dev can only be set by an active auditor which has not submitted a review for the given audit
    */

    function submitFindings(uint ID, uint _low, uint _med, uint _high) public returns(bool) {
        require(auditorAddrToID[msg.sender] != 0); // check if the auditor has been registered;
        require(auditorDetails[auditorAddrToID[msg.sender]].isActive == true); // check if the auditor is active

        require((_high + _med + _low) > 0); // there must be a report submitted otherwise do not submit

        auditorDetails[auditorAddrToID[msg.sender]].numberOfSubmits++;
        auditorDetails[auditorAddrToID[msg.sender]].highs += _high;
        auditorDetails[auditorAddrToID[msg.sender]].meds += _med;
        auditorDetails[auditorAddrToID[msg.sender]].lows += _low;
        auditorDetails[auditorAddrToID[msg.sender]].total += _low + _med + _high;


        if(audits[ID].high == 0 || audits[ID].med == 0 || audits[ID].low == 0) {
            audits[ID].isReviewed = true;
            return true;
        }
    }

    /**
        * @notice finalises the audit process and writes the official findings to state
        * @dev can only be set by owner after an auditor submits their findings and the submitter is happy with the results
        * @param ID ID of the audit
    */

    function finaliseAudit(uint ID, uint _low, uint _med, uint _high, bytes[] memory _lows, bytes[] memory _meds, bytes[] memory _highs) public {
        require(audits[ID].submitter == msg.sender);

        audits[ID].isReviewed = true;
        audits[ID].high = _high;
        audits[ID].med = _med;
        audits[ID].low = _low;

        for(uint x=0; x < _lows.length; x++) {
            lows[ID][x] = abi.encodePacked(_lows[x]);
        }

        for(uint y=0; y < _meds.length; y++) {
            meds[ID][y] = abi.encodePacked(_meds[y]);
        }

        for(uint z=0; z < _highs.length; z++) {
            highs[ID][z] = abi.encodePacked(_highs[z]);
        }

        emit AuditCompleted(_high, _med, _low);
    }



    /**
        * @notice allows externally contracts and wallets to send funds to the this address
    */

    receive() external payable { 
        require(msg.value > 0); 
    }

    
    fallback() external payable {
    }




}
